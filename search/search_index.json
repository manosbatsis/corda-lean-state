{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Corda Restate \u00b6 Are you tired of maintaining consistent Corda Contract to Persistent State mappings? Corda Restate will use annotation processing during your cordapp\u2019s build to (re)generate Corda Contract and Persistent States based on a simplified interface like NewsPaper bellow: @RestateModel interface NewsPaper { val publisher : Party? val author : Party val price : BigDecimal val editions : Int val title : String val published : Date val alternativeTitle : String? } Explicit/custom implementations of linearId , participants , generateMappedObject() , supportedSchemas() etc. in the above interface are optional but rarely needed. Check out the installation , state model and full example sections for more details.","title":"Overview"},{"location":"#corda-restate","text":"Are you tired of maintaining consistent Corda Contract to Persistent State mappings? Corda Restate will use annotation processing during your cordapp\u2019s build to (re)generate Corda Contract and Persistent States based on a simplified interface like NewsPaper bellow: @RestateModel interface NewsPaper { val publisher : Party? val author : Party val price : BigDecimal val editions : Int val title : String val published : Date val alternativeTitle : String? } Explicit/custom implementations of linearId , participants , generateMappedObject() , supportedSchemas() etc. in the above interface are optional but rarely needed. Check out the installation , state model and full example sections for more details.","title":"Corda Restate"},{"location":"changelog/","text":"Changelog \u00b6 The following sections describe major changes per version and can be helpful with version upgrades. 0.1-0.2 \u00b6 WiP releases","title":"Change Log"},{"location":"changelog/#changelog","text":"The following sections describe major changes per version and can be helpful with version upgrades.","title":"Changelog"},{"location":"changelog/#01-02","text":"WiP releases","title":"0.1-0.2"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Answers to common questions. License: Can I use Restate with my project? \u00b6 Yes, Restate can be used as a library/dependency with no side-effect to your project. The project is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"Answers to common questions.","title":"Frequently Asked Questions"},{"location":"faq/#license-can-i-use-restate-with-my-project","text":"Yes, Restate can be used as a library/dependency with no side-effect to your project. The project is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate.","title":"License: Can I use Restate with my project?"},{"location":"full-example/","text":"Full Example \u00b6 Model Interface \u00b6 @RestateModel ( contractClass = NewsPaperContract :: class , // Optional, default is [PropertyMappingMode.EXPANDED] mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? val author : Party val price : BigDecimal val editions : Int val title : String @get : RestateProperty ( initializer = \"Date()\" ) val published : Date @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? } Generated ContractState \u00b6 /** * Generated [ContractState] based on [NewsPaperContract.NewsPaper]. */ @BelongsToContract ( value = NewsPaperContract :: class ) data class NewsPaperContractState ( override val linearId : UniqueIdentifier = UniqueIdentifier (), override val publisher : Party? = null , override val author : Party , override val price : BigDecimal , override val editions : Int , override val title : String , override val published : Date = Date (), override val alternativeTitle : String? = null ) : NewsPaperContract . NewsPaper , ParticipantsState , LinearState , QueryableState { override val participants : List < AbstractParty > get () = toParticipants ( publisher , author ) override fun generateMappedObject ( schema : MappedSchema ): NewsPaperPersistentState = NewsPaperPersistentState ( linearId = linearId , linearIdIdString = linearId . id . toString (), linearIdId = linearId . id , linearIdExternalId = linearId . externalId , publisherName = publisher ?. name , publisherNameString = publisher ?. name ?. toString (), publisherNameCommonName = publisher ?. name ?. commonName , publisherNameOrganisationUnit = publisher ?. name ?. organisationUnit , publisherNameOrganisation = publisher ?. name ?. organisation , publisherNameLocality = publisher ?. name ?. locality , publisherNameState = publisher ?. name ?. state , publisherNameCountry = publisher ?. name ?. country , authorName = author . name , authorNameString = author . name . toString (), authorNameCommonName = author . name . commonName , authorNameOrganisationUnit = author . name . organisationUnit , authorNameOrganisation = author . name . organisation , authorNameLocality = author . name . locality , authorNameState = author . name . state , authorNameCountry = author . name . country , price = price , editions = editions , title = title , published = published , alternativeTitle = alternativeTitle ) override fun supportedSchemas (): Iterable < MappedSchema > = listOf ( SchemaV1 ) object Schema object SchemaV1 : MappedSchema ( Schema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) } Generated PersistentState \u00b6 /** * Custom database schema mapping for [NewsPaperContractState], generated based on * [NewsPaperContract.NewsPaper]. */ @Entity @Table ( name = \"news_paper\" ) class NewsPaperPersistentState ( /** * Enables query criteria for [NewsPaperContractState.linearId]. */ @Column ( name = \"linear_id\" , nullable = false ) val linearId : UniqueIdentifier , /** * Enables query criteria for [NewsPaperContractState.linearId.id] as a [String]. */ @Column ( name = \"linear_id_id_string\" , nullable = false ) val linearIdIdString : String , /** * Enables query criteria for [NewsPaperContractState.linearId.id]. */ @Column ( name = \"linear_id_id\" , nullable = false ) val linearIdId : UUID , /** * Enables query criteria for [NewsPaperContractState.linearId.externalId]. */ @Column ( name = \"linear_id_external_id\" ) val linearIdExternalId : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name]. */ @Column ( name = \"publisher_name\" ) val publisherName : CordaX500Name?, /** * Enables query criteria for [NewsPaperContractState.publisher.name] as a [String]. */ @Column ( name = \"publisher_name_string\" ) val publisherNameString : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.commonName]. */ @Column ( name = \"publisher_name_common_name\" ) val publisherNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisationUnit]. */ @Column ( name = \"publisher_name_organisation_unit\" ) val publisherNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisation]. */ @Column ( name = \"publisher_name_organisation\" ) val publisherNameOrganisation : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.locality]. */ @Column ( name = \"publisher_name_locality\" ) val publisherNameLocality : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.state]. */ @Column ( name = \"publisher_name_state\" ) val publisherNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.country]. */ @Column ( name = \"publisher_name_country\" ) val publisherNameCountry : String? , /** * Enables query criteria for [NewsPaperContractState.author.name]. */ @Column ( name = \"author_name\" , nullable = false ) val authorName : CordaX500Name , /** * Enables query criteria for [NewsPaperContractState.author.name] as a [String]. */ @Column ( name = \"author_name_string\" , nullable = false ) val authorNameString : String , /** * Enables query criteria for [NewsPaperContractState.author.name.commonName]. */ @Column ( name = \"author_name_common_name\" ) val authorNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisationUnit]. */ @Column ( name = \"author_name_organisation_unit\" ) val authorNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisation]. */ @Column ( name = \"author_name_organisation\" , nullable = false ) val authorNameOrganisation : String , /** * Enables query criteria for [NewsPaperContractState.author.name.locality]. */ @Column ( name = \"author_name_locality\" , nullable = false ) val authorNameLocality : String , /** * Enables query criteria for [NewsPaperContractState.author.name.state]. */ @Column ( name = \"author_name_state\" ) val authorNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.country]. */ @Column ( name = \"author_name_country\" , nullable = false ) val authorNameCountry : String , /** * Enables query criteria for [NewsPaperContractState.price]. */ @Column ( name = \"price\" , nullable = false ) val price : BigDecimal , /** * Enables query criteria for [NewsPaperContractState.editions]. */ @Column ( name = \"editions\" , nullable = false ) val editions : Int , /** * Enables query criteria for [NewsPaperContractState.title]. */ @Column ( name = \"title\" , nullable = false ) val title : String , /** * Enables query criteria for [NewsPaperContractState.published]. */ @Column ( name = \"published\" , nullable = false ) val published : Date , /** * Enables query criteria for [NewsPaperContractState.alternativeTitle]. */ @Column ( name = \"description\" , length = 500 ) val alternativeTitle : String? = null ) : PersistentState ()","title":"Full Example"},{"location":"full-example/#full-example","text":"","title":"Full Example"},{"location":"full-example/#model-interface","text":"@RestateModel ( contractClass = NewsPaperContract :: class , // Optional, default is [PropertyMappingMode.EXPANDED] mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? val author : Party val price : BigDecimal val editions : Int val title : String @get : RestateProperty ( initializer = \"Date()\" ) val published : Date @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? }","title":"Model Interface"},{"location":"full-example/#generated-contractstate","text":"/** * Generated [ContractState] based on [NewsPaperContract.NewsPaper]. */ @BelongsToContract ( value = NewsPaperContract :: class ) data class NewsPaperContractState ( override val linearId : UniqueIdentifier = UniqueIdentifier (), override val publisher : Party? = null , override val author : Party , override val price : BigDecimal , override val editions : Int , override val title : String , override val published : Date = Date (), override val alternativeTitle : String? = null ) : NewsPaperContract . NewsPaper , ParticipantsState , LinearState , QueryableState { override val participants : List < AbstractParty > get () = toParticipants ( publisher , author ) override fun generateMappedObject ( schema : MappedSchema ): NewsPaperPersistentState = NewsPaperPersistentState ( linearId = linearId , linearIdIdString = linearId . id . toString (), linearIdId = linearId . id , linearIdExternalId = linearId . externalId , publisherName = publisher ?. name , publisherNameString = publisher ?. name ?. toString (), publisherNameCommonName = publisher ?. name ?. commonName , publisherNameOrganisationUnit = publisher ?. name ?. organisationUnit , publisherNameOrganisation = publisher ?. name ?. organisation , publisherNameLocality = publisher ?. name ?. locality , publisherNameState = publisher ?. name ?. state , publisherNameCountry = publisher ?. name ?. country , authorName = author . name , authorNameString = author . name . toString (), authorNameCommonName = author . name . commonName , authorNameOrganisationUnit = author . name . organisationUnit , authorNameOrganisation = author . name . organisation , authorNameLocality = author . name . locality , authorNameState = author . name . state , authorNameCountry = author . name . country , price = price , editions = editions , title = title , published = published , alternativeTitle = alternativeTitle ) override fun supportedSchemas (): Iterable < MappedSchema > = listOf ( SchemaV1 ) object Schema object SchemaV1 : MappedSchema ( Schema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) }","title":"Generated ContractState"},{"location":"full-example/#generated-persistentstate","text":"/** * Custom database schema mapping for [NewsPaperContractState], generated based on * [NewsPaperContract.NewsPaper]. */ @Entity @Table ( name = \"news_paper\" ) class NewsPaperPersistentState ( /** * Enables query criteria for [NewsPaperContractState.linearId]. */ @Column ( name = \"linear_id\" , nullable = false ) val linearId : UniqueIdentifier , /** * Enables query criteria for [NewsPaperContractState.linearId.id] as a [String]. */ @Column ( name = \"linear_id_id_string\" , nullable = false ) val linearIdIdString : String , /** * Enables query criteria for [NewsPaperContractState.linearId.id]. */ @Column ( name = \"linear_id_id\" , nullable = false ) val linearIdId : UUID , /** * Enables query criteria for [NewsPaperContractState.linearId.externalId]. */ @Column ( name = \"linear_id_external_id\" ) val linearIdExternalId : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name]. */ @Column ( name = \"publisher_name\" ) val publisherName : CordaX500Name?, /** * Enables query criteria for [NewsPaperContractState.publisher.name] as a [String]. */ @Column ( name = \"publisher_name_string\" ) val publisherNameString : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.commonName]. */ @Column ( name = \"publisher_name_common_name\" ) val publisherNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisationUnit]. */ @Column ( name = \"publisher_name_organisation_unit\" ) val publisherNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisation]. */ @Column ( name = \"publisher_name_organisation\" ) val publisherNameOrganisation : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.locality]. */ @Column ( name = \"publisher_name_locality\" ) val publisherNameLocality : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.state]. */ @Column ( name = \"publisher_name_state\" ) val publisherNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.country]. */ @Column ( name = \"publisher_name_country\" ) val publisherNameCountry : String? , /** * Enables query criteria for [NewsPaperContractState.author.name]. */ @Column ( name = \"author_name\" , nullable = false ) val authorName : CordaX500Name , /** * Enables query criteria for [NewsPaperContractState.author.name] as a [String]. */ @Column ( name = \"author_name_string\" , nullable = false ) val authorNameString : String , /** * Enables query criteria for [NewsPaperContractState.author.name.commonName]. */ @Column ( name = \"author_name_common_name\" ) val authorNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisationUnit]. */ @Column ( name = \"author_name_organisation_unit\" ) val authorNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisation]. */ @Column ( name = \"author_name_organisation\" , nullable = false ) val authorNameOrganisation : String , /** * Enables query criteria for [NewsPaperContractState.author.name.locality]. */ @Column ( name = \"author_name_locality\" , nullable = false ) val authorNameLocality : String , /** * Enables query criteria for [NewsPaperContractState.author.name.state]. */ @Column ( name = \"author_name_state\" ) val authorNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.country]. */ @Column ( name = \"author_name_country\" , nullable = false ) val authorNameCountry : String , /** * Enables query criteria for [NewsPaperContractState.price]. */ @Column ( name = \"price\" , nullable = false ) val price : BigDecimal , /** * Enables query criteria for [NewsPaperContractState.editions]. */ @Column ( name = \"editions\" , nullable = false ) val editions : Int , /** * Enables query criteria for [NewsPaperContractState.title]. */ @Column ( name = \"title\" , nullable = false ) val title : String , /** * Enables query criteria for [NewsPaperContractState.published]. */ @Column ( name = \"published\" , nullable = false ) val published : Date , /** * Enables query criteria for [NewsPaperContractState.alternativeTitle]. */ @Column ( name = \"description\" , length = 500 ) val alternativeTitle : String? = null ) : PersistentState ()","title":"Generated PersistentState"},{"location":"installation/","text":"Installation \u00b6 Step 1: Add to your Cordapp\u2019s Gradle dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.corda.restate:restate-contracts:$restate_version\" // Annotation processing kapt \"com.github.manosbatsis.corda.restate:restate-processor:$restate_version\" // Corda dependencies etc. // ... } Alternatively, you might want to add Restate in the Cordapp\u2019s fat JAR, in which case use compile instead of cordacompile and skip step 2 bellow. Step 2: Add Restate as a Cordapp to your deployNodes / dockerNodes task: // Core dependency cordapp \"com.github.manosbatsis.corda.restate:restate-contracts:$restate_version\" Step 3: You may also want to add the generated sources to your cordapp\u2019s Gradle sourceSets : // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } }","title":"Installation"},{"location":"installation/#installation","text":"Step 1: Add to your Cordapp\u2019s Gradle dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.corda.restate:restate-contracts:$restate_version\" // Annotation processing kapt \"com.github.manosbatsis.corda.restate:restate-processor:$restate_version\" // Corda dependencies etc. // ... } Alternatively, you might want to add Restate in the Cordapp\u2019s fat JAR, in which case use compile instead of cordacompile and skip step 2 bellow. Step 2: Add Restate as a Cordapp to your deployNodes / dockerNodes task: // Core dependency cordapp \"com.github.manosbatsis.corda.restate:restate-contracts:$restate_version\" Step 3: You may also want to add the generated sources to your cordapp\u2019s Gradle sourceSets : // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } }","title":"Installation"},{"location":"state-model/","text":"State Model \u00b6 Sample State \u00b6 Let\u2019s start with a simple state model: /** Our contract class */ class NewsPaperContract : Contract { /** State definition */ @RestateModel interface NewsPaper { val publisher : Party? val author : Party //... } } Targeting a Contract \u00b6 In the above example the NewsPaper type is contained in a Corda Contract so there is no need to specify the contract type target for the generated ContractState . If NewsPaper was in a standalone file, we would specify the contract using RestateModel.contractClass : /** Standalone state definition */ @RestateModel ( contractClass = NewsPaperContract :: class ) interface NewsPaper { val publisher : Party? val author : Party //... } or using a classname string with RestateModel.contractClassName : /** Standalone state definition */ @RestateModel ( contractClassName = \"my.package.NewsPaperContract\" ) interface NewsPaper { val publisher : Party? val author : Party //... } Overriding LinearState \u00b6 If, for whatever reason, you need to customise the overrides for LinearState you can do it in your interface. The annotation processor will honor them by not generating its own. /** State definition */ @RestateModel interface NewsPaper : LinearState { val publisher : Party? val author : Party //... // Optional, no need to add or override explicitly override val linearId : UniqueIdentifier // Optionally override LinearState.participants // if you don't want the implementation generated by default override val participants get () = listOfNotNull ( publisher ?. party , author . party ) } Overriding QueryableState \u00b6 You can also customise overrides for QueryableState and, similarly as above, the annotation processor will honor them by not generating its own. @RestateModel interface NewsPaper : QueryableState { val publisher : Party? val author : Party //... // Optional, only override to use a custom implementation // VS the default strategy. override fun generateMappedObject ( schema : MappedSchema ) = NewsPaperPersistentState ( // ... ) // Only extend QueryableState and override if you don't want the implementation generated by default override fun supportedSchemas () = listOf ( SchemaV1 ) // Only add if you explicitly implement supportedSchemas() object Schema object NSchemaV1 : MappedSchema ( NewsPaperSchema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) } Default Participants \u00b6 The default strategy used by the annotation processor scans your interface and uses members of the following types to create the default participants implementation: net.corda.core.identity.Party net.corda.core.identity.AbstractParty net.corda.core.identity.AnonymousParty java.security.PublicKey Types with a proper party member, e.g. com.github.manosbatsis.vaultaire.dto.AccountParty Any collection parameterised with one of the above Property Mapping Modes \u00b6 [RestateModel] and [RestateProperty] annotations allow configuration of Contract to Persistent State property mappings using one or more of the following: NATIVE : Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY : Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED : Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members. // Tweak mapping modes at type level, // default is [PropertyMappingMode.EXPANDED], @RestateModel ( mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? // Tweak modes at property level @RestateProperty ( mappingModes = [ PropertyMappingMode . STRINGIFY ] ) val author : Party //... } JPA Overrides \u00b6 JPA @Column annotations found in your model interface will be copied as-is, overriding the annotation processor defaults. @RestateModel interface NewsPaper { // Override JPA Column generation @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? //... }","title":"State Model"},{"location":"state-model/#state-model","text":"","title":"State Model"},{"location":"state-model/#sample-state","text":"Let\u2019s start with a simple state model: /** Our contract class */ class NewsPaperContract : Contract { /** State definition */ @RestateModel interface NewsPaper { val publisher : Party? val author : Party //... } }","title":"Sample State"},{"location":"state-model/#targeting-a-contract","text":"In the above example the NewsPaper type is contained in a Corda Contract so there is no need to specify the contract type target for the generated ContractState . If NewsPaper was in a standalone file, we would specify the contract using RestateModel.contractClass : /** Standalone state definition */ @RestateModel ( contractClass = NewsPaperContract :: class ) interface NewsPaper { val publisher : Party? val author : Party //... } or using a classname string with RestateModel.contractClassName : /** Standalone state definition */ @RestateModel ( contractClassName = \"my.package.NewsPaperContract\" ) interface NewsPaper { val publisher : Party? val author : Party //... }","title":"Targeting a Contract"},{"location":"state-model/#overriding-linearstate","text":"If, for whatever reason, you need to customise the overrides for LinearState you can do it in your interface. The annotation processor will honor them by not generating its own. /** State definition */ @RestateModel interface NewsPaper : LinearState { val publisher : Party? val author : Party //... // Optional, no need to add or override explicitly override val linearId : UniqueIdentifier // Optionally override LinearState.participants // if you don't want the implementation generated by default override val participants get () = listOfNotNull ( publisher ?. party , author . party ) }","title":"Overriding LinearState"},{"location":"state-model/#overriding-queryablestate","text":"You can also customise overrides for QueryableState and, similarly as above, the annotation processor will honor them by not generating its own. @RestateModel interface NewsPaper : QueryableState { val publisher : Party? val author : Party //... // Optional, only override to use a custom implementation // VS the default strategy. override fun generateMappedObject ( schema : MappedSchema ) = NewsPaperPersistentState ( // ... ) // Only extend QueryableState and override if you don't want the implementation generated by default override fun supportedSchemas () = listOf ( SchemaV1 ) // Only add if you explicitly implement supportedSchemas() object Schema object NSchemaV1 : MappedSchema ( NewsPaperSchema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) }","title":"Overriding QueryableState"},{"location":"state-model/#default-participants","text":"The default strategy used by the annotation processor scans your interface and uses members of the following types to create the default participants implementation: net.corda.core.identity.Party net.corda.core.identity.AbstractParty net.corda.core.identity.AnonymousParty java.security.PublicKey Types with a proper party member, e.g. com.github.manosbatsis.vaultaire.dto.AccountParty Any collection parameterised with one of the above","title":"Default Participants"},{"location":"state-model/#property-mapping-modes","text":"[RestateModel] and [RestateProperty] annotations allow configuration of Contract to Persistent State property mappings using one or more of the following: NATIVE : Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY : Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED : Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members. // Tweak mapping modes at type level, // default is [PropertyMappingMode.EXPANDED], @RestateModel ( mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? // Tweak modes at property level @RestateProperty ( mappingModes = [ PropertyMappingMode . STRINGIFY ] ) val author : Party //... }","title":"Property Mapping Modes"},{"location":"state-model/#jpa-overrides","text":"JPA @Column annotations found in your model interface will be copied as-is, overriding the annotation processor defaults. @RestateModel interface NewsPaper { // Override JPA Column generation @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? //... }","title":"JPA Overrides"},{"location":"0.x/","text":"Packages \u00b6 Name Summary com.github.manosbatsis.corda.restate.annotation Index \u00b6 All Types","title":"Index"},{"location":"0.x/#packages","text":"Name Summary com.github.manosbatsis.corda.restate.annotation","title":"Packages"},{"location":"0.x/#index","text":"All Types","title":"Index"},{"location":"0.x/alltypes/","text":"All Types \u00b6 Name Summary com.github.manosbatsis.corda.restate.annotation.NONE com.github.manosbatsis.corda.restate.annotation.ParticipantsState Helpers for (generated) implementations of ContractState.participants . com.github.manosbatsis.corda.restate.annotation.PropertyMappingMode Used by RestateModel and RestateProperty to apply one or more mapping modes in generated contract > persistent states. com.github.manosbatsis.corda.restate.annotation.RestateModel Generate ContractState , PersistentState types based on the annotated interface. com.github.manosbatsis.corda.restate.annotation.RestateProperty Property-level equivalent of RestateModel","title":"Index"},{"location":"0.x/alltypes/#all-types","text":"Name Summary com.github.manosbatsis.corda.restate.annotation.NONE com.github.manosbatsis.corda.restate.annotation.ParticipantsState Helpers for (generated) implementations of ContractState.participants . com.github.manosbatsis.corda.restate.annotation.PropertyMappingMode Used by RestateModel and RestateProperty to apply one or more mapping modes in generated contract > persistent states. com.github.manosbatsis.corda.restate.annotation.RestateModel Generate ContractState , PersistentState types based on the annotated interface. com.github.manosbatsis.corda.restate.annotation.RestateProperty Property-level equivalent of RestateModel","title":"All Types"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/","text":"com.github.manosbatsis.corda.restate.annotation Package com.github.manosbatsis.corda.restate.annotation \u00b6 Types \u00b6 Name Summary NONE class NONE ParticipantsState interface ParticipantsState Helpers for (generated) implementations of ContractState.participants . PropertyMappingMode enum class PropertyMappingMode Used by RestateModel and RestateProperty to apply one or more mapping modes in generated contract > persistent states. Annotations \u00b6 Name Summary RestateModel annotation class RestateModel Generate ContractState , PersistentState types based on the annotated interface. RestateProperty annotation class RestateProperty Property-level equivalent of RestateModel","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/#package-comgithubmanosbatsiscordarestateannotation","text":"","title":"Package com.github.manosbatsis.corda.restate.annotation"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/#types","text":"Name Summary NONE class NONE ParticipantsState interface ParticipantsState Helpers for (generated) implementations of ContractState.participants . PropertyMappingMode enum class PropertyMappingMode Used by RestateModel and RestateProperty to apply one or more mapping modes in generated contract > persistent states.","title":"Types"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/#annotations","text":"Name Summary RestateModel annotation class RestateModel Generate ContractState , PersistentState types based on the annotated interface. RestateProperty annotation class RestateProperty Property-level equivalent of RestateModel","title":"Annotations"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-n-o-n-e/","text":"com.github.manosbatsis.corda.restate.annotation / NONE NONE \u00b6 class NONE Constructors \u00b6 Name Summary <init> NONE()","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-n-o-n-e/#none","text":"class NONE","title":"NONE"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-n-o-n-e/#constructors","text":"Name Summary <init> NONE()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-n-o-n-e/-init-/","text":"com.github.manosbatsis.corda.restate.annotation / NONE / <init> <init> \u00b6 NONE()","title":" init "},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-n-o-n-e/-init-/#init","text":"NONE()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/","text":"com.github.manosbatsis.corda.restate.annotation / ParticipantsState ParticipantsState \u00b6 interface ParticipantsState Helpers for (generated) implementations of ContractState.participants . Functions \u00b6 Name Summary toAbstractParties open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty> toAbstractParty open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty toParticipants open fun toParticipants(vararg entry: Any?): List<AbstractParty> Companion Object Functions \u00b6 Name Summary getField fun Any.getField(fieldName: String): Any? isKotlinClass fun Class<*>.isKotlinClass(): Boolean isKotlinType fun Any.isKotlinType(): Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/#participantsstate","text":"interface ParticipantsState Helpers for (generated) implementations of ContractState.participants .","title":"ParticipantsState"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/#functions","text":"Name Summary toAbstractParties open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty> toAbstractParty open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty toParticipants open fun toParticipants(vararg entry: Any?): List<AbstractParty>","title":"Functions"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/#companion-object-functions","text":"Name Summary getField fun Any.getField(fieldName: String): Any? isKotlinClass fun Class<*>.isKotlinClass(): Boolean isKotlinType fun Any.isKotlinType(): Boolean","title":"Companion Object Functions"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/get-field/","text":"com.github.manosbatsis.corda.restate.annotation / ParticipantsState / getField getField \u00b6 fun Any.getField(fieldName: String): Any?","title":"Get field"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/get-field/#getfield","text":"fun Any.getField(fieldName: String): Any?","title":"getField"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/is-kotlin-class/","text":"com.github.manosbatsis.corda.restate.annotation / ParticipantsState / isKotlinClass isKotlinClass \u00b6 fun Class<*>.isKotlinClass(): Boolean","title":"Is kotlin class"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/is-kotlin-class/#iskotlinclass","text":"fun Class<*>.isKotlinClass(): Boolean","title":"isKotlinClass"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/is-kotlin-type/","text":"com.github.manosbatsis.corda.restate.annotation / ParticipantsState / isKotlinType isKotlinType \u00b6 fun Any.isKotlinType(): Boolean","title":"Is kotlin type"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/is-kotlin-type/#iskotlintype","text":"fun Any.isKotlinType(): Boolean","title":"isKotlinType"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/to-abstract-parties/","text":"com.github.manosbatsis.corda.restate.annotation / ParticipantsState / toAbstractParties toAbstractParties \u00b6 open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty>","title":"To abstract parties"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/to-abstract-parties/#toabstractparties","text":"open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty>","title":"toAbstractParties"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/to-abstract-party/","text":"com.github.manosbatsis.corda.restate.annotation / ParticipantsState / toAbstractParty toAbstractParty \u00b6 open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty","title":"To abstract party"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/to-abstract-party/#toabstractparty","text":"open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty","title":"toAbstractParty"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/to-participants/","text":"com.github.manosbatsis.corda.restate.annotation / ParticipantsState / toParticipants toParticipants \u00b6 open fun toParticipants(vararg entry: Any?): List<AbstractParty>","title":"To participants"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-participants-state/to-participants/#toparticipants","text":"open fun toParticipants(vararg entry: Any?): List<AbstractParty>","title":"toParticipants"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/","text":"com.github.manosbatsis.corda.restate.annotation / PropertyMappingMode PropertyMappingMode \u00b6 enum class PropertyMappingMode Used by RestateModel and RestateProperty to apply one or more mapping modes in generated contract > persistent states. Enum Values \u00b6 Name Summary NATIVE Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/#propertymappingmode","text":"enum class PropertyMappingMode Used by RestateModel and RestateProperty to apply one or more mapping modes in generated contract > persistent states.","title":"PropertyMappingMode"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/#enum-values","text":"Name Summary NATIVE Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":"Enum Values"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/-e-x-p-a-n-d-e-d/","text":"com.github.manosbatsis.corda.restate.annotation / PropertyMappingMode / EXPANDED EXPANDED \u00b6 EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":" e x p a n d e d"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/-e-x-p-a-n-d-e-d/#expanded","text":"EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":"EXPANDED"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/-n-a-t-i-v-e/","text":"com.github.manosbatsis.corda.restate.annotation / PropertyMappingMode / NATIVE NATIVE \u00b6 NATIVE Will generate PersistentState fields using the original ContractState field if possible.","title":" n a t i v e"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/-n-a-t-i-v-e/#native","text":"NATIVE Will generate PersistentState fields using the original ContractState field if possible.","title":"NATIVE"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/-s-t-r-i-n-g-i-f-y/","text":"com.github.manosbatsis.corda.restate.annotation / PropertyMappingMode / STRINGIFY STRINGIFY \u00b6 STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d.","title":" s t r i n g i f y"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-property-mapping-mode/-s-t-r-i-n-g-i-f-y/#stringify","text":"STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d.","title":"STRINGIFY"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel RestateModel \u00b6 @Target([AnnotationTarget.CLASS]) annotation class RestateModel Generate ContractState , PersistentState types based on the annotated interface. Constructors \u00b6 Name Summary <init> RestateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\") Generate ContractState , PersistentState types based on the annotated interface. Properties \u00b6 Name Summary contractClass val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type. contractClassName val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time. contractStateInterface val contractStateInterface: KClass<out ContractState> contractStateName val contractStateName: String copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via RestateProperty annotations. persistentStateName val persistentStateName: String","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/#restatemodel","text":"@Target([AnnotationTarget.CLASS]) annotation class RestateModel Generate ContractState , PersistentState types based on the annotated interface.","title":"RestateModel"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/#constructors","text":"Name Summary <init> RestateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\") Generate ContractState , PersistentState types based on the annotated interface.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/#properties","text":"Name Summary contractClass val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type. contractClassName val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time. contractStateInterface val contractStateInterface: KClass<out ContractState> contractStateName val contractStateName: String copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via RestateProperty annotations. persistentStateName val persistentStateName: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/-init-/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / <init> <init> \u00b6 RestateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\") Generate ContractState , PersistentState types based on the annotated interface.","title":" init "},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/-init-/#init","text":"RestateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\") Generate ContractState , PersistentState types based on the annotated interface.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-class-name/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / contractClassName contractClassName \u00b6 val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time.","title":"Contract class name"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-class-name/#contractclassname","text":"val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time.","title":"contractClassName"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-class/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / contractClass contractClass \u00b6 val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type.","title":"Contract class"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-class/#contractclass","text":"val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type.","title":"contractClass"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-state-interface/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / contractStateInterface contractStateInterface \u00b6 val contractStateInterface: KClass<out ContractState>","title":"Contract state interface"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-state-interface/#contractstateinterface","text":"val contractStateInterface: KClass<out ContractState>","title":"contractStateInterface"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-state-name/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / contractStateName contractStateName \u00b6 val contractStateName: String","title":"Contract state name"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/contract-state-name/#contractstatename","text":"val contractStateName: String","title":"contractStateName"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/copy-annotation-packages/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / copyAnnotationPackages copyAnnotationPackages \u00b6 val copyAnnotationPackages: Array<String>","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array<String>","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/ignore-properties/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / ignoreProperties ignoreProperties \u00b6 val ignoreProperties: Array<String>","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array<String>","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/mapping-modes/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / mappingModes mappingModes \u00b6 val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via RestateProperty annotations.","title":"Mapping modes"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/mapping-modes/#mappingmodes","text":"val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via RestateProperty annotations.","title":"mappingModes"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/persistent-state-name/","text":"com.github.manosbatsis.corda.restate.annotation / RestateModel / persistentStateName persistentStateName \u00b6 val persistentStateName: String","title":"Persistent state name"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-model/persistent-state-name/#persistentstatename","text":"val persistentStateName: String","title":"persistentStateName"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/","text":"com.github.manosbatsis.corda.restate.annotation / RestateProperty RestateProperty \u00b6 @Target([AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class RestateProperty Property-level equivalent of RestateModel Constructors \u00b6 Name Summary <init> RestateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of RestateModel Properties \u00b6 Name Summary initializer val initializer: String mapper val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property. mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/#restateproperty","text":"@Target([AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class RestateProperty Property-level equivalent of RestateModel","title":"RestateProperty"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/#constructors","text":"Name Summary <init> RestateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of RestateModel","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/#properties","text":"Name Summary initializer val initializer: String mapper val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property. mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"Properties"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/-init-/","text":"com.github.manosbatsis.corda.restate.annotation / RestateProperty / <init> <init> \u00b6 RestateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of RestateModel","title":" init "},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/-init-/#init","text":"RestateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of RestateModel","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/initializer/","text":"com.github.manosbatsis.corda.restate.annotation / RestateProperty / initializer initializer \u00b6 val initializer: String","title":"Initializer"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/initializer/#initializer","text":"val initializer: String","title":"initializer"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/mapper/","text":"com.github.manosbatsis.corda.restate.annotation / RestateProperty / mapper mapper \u00b6 val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property.","title":"Mapper"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/mapper/#mapper","text":"val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property.","title":"mapper"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/mapping-modes/","text":"com.github.manosbatsis.corda.restate.annotation / RestateProperty / mappingModes mappingModes \u00b6 val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"Mapping modes"},{"location":"0.x/com.github.manosbatsis.corda.restate.annotation/-restate-property/mapping-modes/#mappingmodes","text":"val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"mappingModes"}]}