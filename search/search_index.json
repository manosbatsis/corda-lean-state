{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Corda LeanState \u00b6 Shamelessly lazy or simply tired of manually maintaining ContractState / PersistentState mappings? LeanState (re)generates perfectly synced and consistent state classes at build-time, based on model interfaces like NewsPaper bellow as input: @LeanStateModel interface NewsPaper { val publisher : Party? //... } You can (optionally!) extend Corda\u2019s standard interfaces if you really need custom overrides VS those added by the processor (e.g. for supportedSchemas() ). The processor will refrain from generating its own if you do. Such a requirement should be rare as generation is configurable in a few ways, see state model and full example sections for details. Here\u2019s what NewsPaper above will generate with default settings (edited for brevity). Contract state: @BelongsToContract ( value = NewsPaperContract :: class ) data class NewsPaperContractState ( override val linearId : UniqueIdentifier = UniqueIdentifier (), override val publisher : Party? = null , //... ) : NewsPaperContract . NewsPaper , ParticipantsState , LinearState , QueryableState { override val participants : List < AbstractParty > = //... override fun generateMappedObject ( schema : MappedSchema ): NewsPaperPersistentState = //... override fun supportedSchemas (): Iterable < MappedSchema > = listOf ( SchemaV1 ) object Schema object SchemaV1 : MappedSchema ( Schema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) } Persistent state (edited for brevity): @Entity @Table ( name = \"news_paper\" ) class NewsPaperPersistentState ( @Column ( name = \"linear_id_id\" , nullable = false ) val linearIdId : UUID , @Column ( name = \"linear_id_external_id\" ) val linearIdExternalId : String? = null , @Column ( name = \"publisher_name_common_name\" ) val publisherNameCommonName : String? = null , @Column ( name = \"publisher_name_organisation_unit\" ) val publisherNameOrganisationUnit : String? = null , @Column ( name = \"publisher_name_organisation\" ) val publisherNameOrganisation : String? , @Column ( name = \"publisher_name_locality\" ) val publisherNameLocality : String? , @Column ( name = \"publisher_name_state\" ) val publisherNameState : String? = null , @Column ( name = \"publisher_name_country\" ) val publisherNameCountry : String? , //... ) : PersistentState ()","title":"Overview"},{"location":"#corda-leanstate","text":"Shamelessly lazy or simply tired of manually maintaining ContractState / PersistentState mappings? LeanState (re)generates perfectly synced and consistent state classes at build-time, based on model interfaces like NewsPaper bellow as input: @LeanStateModel interface NewsPaper { val publisher : Party? //... } You can (optionally!) extend Corda\u2019s standard interfaces if you really need custom overrides VS those added by the processor (e.g. for supportedSchemas() ). The processor will refrain from generating its own if you do. Such a requirement should be rare as generation is configurable in a few ways, see state model and full example sections for details. Here\u2019s what NewsPaper above will generate with default settings (edited for brevity). Contract state: @BelongsToContract ( value = NewsPaperContract :: class ) data class NewsPaperContractState ( override val linearId : UniqueIdentifier = UniqueIdentifier (), override val publisher : Party? = null , //... ) : NewsPaperContract . NewsPaper , ParticipantsState , LinearState , QueryableState { override val participants : List < AbstractParty > = //... override fun generateMappedObject ( schema : MappedSchema ): NewsPaperPersistentState = //... override fun supportedSchemas (): Iterable < MappedSchema > = listOf ( SchemaV1 ) object Schema object SchemaV1 : MappedSchema ( Schema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) } Persistent state (edited for brevity): @Entity @Table ( name = \"news_paper\" ) class NewsPaperPersistentState ( @Column ( name = \"linear_id_id\" , nullable = false ) val linearIdId : UUID , @Column ( name = \"linear_id_external_id\" ) val linearIdExternalId : String? = null , @Column ( name = \"publisher_name_common_name\" ) val publisherNameCommonName : String? = null , @Column ( name = \"publisher_name_organisation_unit\" ) val publisherNameOrganisationUnit : String? = null , @Column ( name = \"publisher_name_organisation\" ) val publisherNameOrganisation : String? , @Column ( name = \"publisher_name_locality\" ) val publisherNameLocality : String? , @Column ( name = \"publisher_name_state\" ) val publisherNameState : String? = null , @Column ( name = \"publisher_name_country\" ) val publisherNameCountry : String? , //... ) : PersistentState ()","title":"Corda LeanState"},{"location":"changelog/","text":"Changelog \u00b6 The following sections describe major changes per version and can be helpful with version upgrades. 0.1 to \u00b6 Early releases","title":"Change Log"},{"location":"changelog/#changelog","text":"The following sections describe major changes per version and can be helpful with version upgrades.","title":"Changelog"},{"location":"changelog/#01-to","text":"Early releases","title":"0.1 to"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Answers to common questions. License: Can I use LeanState with my project? \u00b6 Yes, LeanState can be used as a library/dependency with no side-effect to your project. The project is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"Answers to common questions.","title":"Frequently Asked Questions"},{"location":"faq/#license-can-i-use-leanstate-with-my-project","text":"Yes, LeanState can be used as a library/dependency with no side-effect to your project. The project is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate.","title":"License: Can I use LeanState with my project?"},{"location":"full-example/","text":"Full Example \u00b6 Model Interface \u00b6 @LeanStateModel ( contractClass = NewsPaperContract :: class , // Optional, default is [PropertyMappingMode.EXPANDED] mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? val author : Party val price : BigDecimal val editions : Int val title : String @get : LeanStateProperty ( initializer = \"Date()\" ) val published : Date @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? } Generated ContractState \u00b6 /** * Generated [ContractState] based on [NewsPaperContract.NewsPaper]. */ @BelongsToContract ( value = NewsPaperContract :: class ) data class NewsPaperContractState ( override val linearId : UniqueIdentifier = UniqueIdentifier (), override val publisher : Party? = null , override val author : Party , override val price : BigDecimal , override val editions : Int , override val title : String , override val published : Date = Date (), override val alternativeTitle : String? = null ) : NewsPaperContract . NewsPaper , ParticipantsState , LinearState , QueryableState { override val participants : List < AbstractParty > get () = toParticipants ( publisher , author ) override fun generateMappedObject ( schema : MappedSchema ): NewsPaperPersistentState = NewsPaperPersistentState ( linearId = linearId , linearIdIdString = linearId . id . toString (), linearIdId = linearId . id , linearIdExternalId = linearId . externalId , publisherName = publisher ?. name , publisherNameString = publisher ?. name ?. toString (), publisherNameCommonName = publisher ?. name ?. commonName , publisherNameOrganisationUnit = publisher ?. name ?. organisationUnit , publisherNameOrganisation = publisher ?. name ?. organisation , publisherNameLocality = publisher ?. name ?. locality , publisherNameState = publisher ?. name ?. state , publisherNameCountry = publisher ?. name ?. country , authorName = author . name , authorNameString = author . name . toString (), authorNameCommonName = author . name . commonName , authorNameOrganisationUnit = author . name . organisationUnit , authorNameOrganisation = author . name . organisation , authorNameLocality = author . name . locality , authorNameState = author . name . state , authorNameCountry = author . name . country , price = price , editions = editions , title = title , published = published , alternativeTitle = alternativeTitle ) override fun supportedSchemas (): Iterable < MappedSchema > = listOf ( SchemaV1 ) object Schema object SchemaV1 : MappedSchema ( Schema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) } Generated PersistentState \u00b6 /** * Custom database schema mapping for [NewsPaperContractState], generated based on * [NewsPaperContract.NewsPaper]. */ @Entity @Table ( name = \"news_paper\" ) class NewsPaperPersistentState ( /** * Enables query criteria for [NewsPaperContractState.linearId]. */ @Column ( name = \"linear_id\" , nullable = false ) val linearId : UniqueIdentifier , /** * Enables query criteria for [NewsPaperContractState.linearId.id] as a [String]. */ @Column ( name = \"linear_id_id_string\" , nullable = false ) val linearIdIdString : String , /** * Enables query criteria for [NewsPaperContractState.linearId.id]. */ @Column ( name = \"linear_id_id\" , nullable = false ) val linearIdId : UUID , /** * Enables query criteria for [NewsPaperContractState.linearId.externalId]. */ @Column ( name = \"linear_id_external_id\" ) val linearIdExternalId : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name]. */ @Column ( name = \"publisher_name\" ) val publisherName : CordaX500Name?, /** * Enables query criteria for [NewsPaperContractState.publisher.name] as a [String]. */ @Column ( name = \"publisher_name_string\" ) val publisherNameString : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.commonName]. */ @Column ( name = \"publisher_name_common_name\" ) val publisherNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisationUnit]. */ @Column ( name = \"publisher_name_organisation_unit\" ) val publisherNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisation]. */ @Column ( name = \"publisher_name_organisation\" ) val publisherNameOrganisation : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.locality]. */ @Column ( name = \"publisher_name_locality\" ) val publisherNameLocality : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.state]. */ @Column ( name = \"publisher_name_state\" ) val publisherNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.country]. */ @Column ( name = \"publisher_name_country\" ) val publisherNameCountry : String? , /** * Enables query criteria for [NewsPaperContractState.author.name]. */ @Column ( name = \"author_name\" , nullable = false ) val authorName : CordaX500Name , /** * Enables query criteria for [NewsPaperContractState.author.name] as a [String]. */ @Column ( name = \"author_name_string\" , nullable = false ) val authorNameString : String , /** * Enables query criteria for [NewsPaperContractState.author.name.commonName]. */ @Column ( name = \"author_name_common_name\" ) val authorNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisationUnit]. */ @Column ( name = \"author_name_organisation_unit\" ) val authorNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisation]. */ @Column ( name = \"author_name_organisation\" , nullable = false ) val authorNameOrganisation : String , /** * Enables query criteria for [NewsPaperContractState.author.name.locality]. */ @Column ( name = \"author_name_locality\" , nullable = false ) val authorNameLocality : String , /** * Enables query criteria for [NewsPaperContractState.author.name.state]. */ @Column ( name = \"author_name_state\" ) val authorNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.country]. */ @Column ( name = \"author_name_country\" , nullable = false ) val authorNameCountry : String , /** * Enables query criteria for [NewsPaperContractState.price]. */ @Column ( name = \"price\" , nullable = false ) val price : BigDecimal , /** * Enables query criteria for [NewsPaperContractState.editions]. */ @Column ( name = \"editions\" , nullable = false ) val editions : Int , /** * Enables query criteria for [NewsPaperContractState.title]. */ @Column ( name = \"title\" , nullable = false ) val title : String , /** * Enables query criteria for [NewsPaperContractState.published]. */ @Column ( name = \"published\" , nullable = false ) val published : Date , /** * Enables query criteria for [NewsPaperContractState.alternativeTitle]. */ @Column ( name = \"description\" , length = 500 ) val alternativeTitle : String? = null ) : PersistentState ()","title":"Full Example"},{"location":"full-example/#full-example","text":"","title":"Full Example"},{"location":"full-example/#model-interface","text":"@LeanStateModel ( contractClass = NewsPaperContract :: class , // Optional, default is [PropertyMappingMode.EXPANDED] mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? val author : Party val price : BigDecimal val editions : Int val title : String @get : LeanStateProperty ( initializer = \"Date()\" ) val published : Date @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? }","title":"Model Interface"},{"location":"full-example/#generated-contractstate","text":"/** * Generated [ContractState] based on [NewsPaperContract.NewsPaper]. */ @BelongsToContract ( value = NewsPaperContract :: class ) data class NewsPaperContractState ( override val linearId : UniqueIdentifier = UniqueIdentifier (), override val publisher : Party? = null , override val author : Party , override val price : BigDecimal , override val editions : Int , override val title : String , override val published : Date = Date (), override val alternativeTitle : String? = null ) : NewsPaperContract . NewsPaper , ParticipantsState , LinearState , QueryableState { override val participants : List < AbstractParty > get () = toParticipants ( publisher , author ) override fun generateMappedObject ( schema : MappedSchema ): NewsPaperPersistentState = NewsPaperPersistentState ( linearId = linearId , linearIdIdString = linearId . id . toString (), linearIdId = linearId . id , linearIdExternalId = linearId . externalId , publisherName = publisher ?. name , publisherNameString = publisher ?. name ?. toString (), publisherNameCommonName = publisher ?. name ?. commonName , publisherNameOrganisationUnit = publisher ?. name ?. organisationUnit , publisherNameOrganisation = publisher ?. name ?. organisation , publisherNameLocality = publisher ?. name ?. locality , publisherNameState = publisher ?. name ?. state , publisherNameCountry = publisher ?. name ?. country , authorName = author . name , authorNameString = author . name . toString (), authorNameCommonName = author . name . commonName , authorNameOrganisationUnit = author . name . organisationUnit , authorNameOrganisation = author . name . organisation , authorNameLocality = author . name . locality , authorNameState = author . name . state , authorNameCountry = author . name . country , price = price , editions = editions , title = title , published = published , alternativeTitle = alternativeTitle ) override fun supportedSchemas (): Iterable < MappedSchema > = listOf ( SchemaV1 ) object Schema object SchemaV1 : MappedSchema ( Schema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) }","title":"Generated ContractState"},{"location":"full-example/#generated-persistentstate","text":"/** * Custom database schema mapping for [NewsPaperContractState], generated based on * [NewsPaperContract.NewsPaper]. */ @Entity @Table ( name = \"news_paper\" ) class NewsPaperPersistentState ( /** * Enables query criteria for [NewsPaperContractState.linearId]. */ @Column ( name = \"linear_id\" , nullable = false ) val linearId : UniqueIdentifier , /** * Enables query criteria for [NewsPaperContractState.linearId.id] as a [String]. */ @Column ( name = \"linear_id_id_string\" , nullable = false ) val linearIdIdString : String , /** * Enables query criteria for [NewsPaperContractState.linearId.id]. */ @Column ( name = \"linear_id_id\" , nullable = false ) val linearIdId : UUID , /** * Enables query criteria for [NewsPaperContractState.linearId.externalId]. */ @Column ( name = \"linear_id_external_id\" ) val linearIdExternalId : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name]. */ @Column ( name = \"publisher_name\" ) val publisherName : CordaX500Name?, /** * Enables query criteria for [NewsPaperContractState.publisher.name] as a [String]. */ @Column ( name = \"publisher_name_string\" ) val publisherNameString : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.commonName]. */ @Column ( name = \"publisher_name_common_name\" ) val publisherNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisationUnit]. */ @Column ( name = \"publisher_name_organisation_unit\" ) val publisherNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.organisation]. */ @Column ( name = \"publisher_name_organisation\" ) val publisherNameOrganisation : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.locality]. */ @Column ( name = \"publisher_name_locality\" ) val publisherNameLocality : String? , /** * Enables query criteria for [NewsPaperContractState.publisher.name.state]. */ @Column ( name = \"publisher_name_state\" ) val publisherNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.publisher.name.country]. */ @Column ( name = \"publisher_name_country\" ) val publisherNameCountry : String? , /** * Enables query criteria for [NewsPaperContractState.author.name]. */ @Column ( name = \"author_name\" , nullable = false ) val authorName : CordaX500Name , /** * Enables query criteria for [NewsPaperContractState.author.name] as a [String]. */ @Column ( name = \"author_name_string\" , nullable = false ) val authorNameString : String , /** * Enables query criteria for [NewsPaperContractState.author.name.commonName]. */ @Column ( name = \"author_name_common_name\" ) val authorNameCommonName : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisationUnit]. */ @Column ( name = \"author_name_organisation_unit\" ) val authorNameOrganisationUnit : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.organisation]. */ @Column ( name = \"author_name_organisation\" , nullable = false ) val authorNameOrganisation : String , /** * Enables query criteria for [NewsPaperContractState.author.name.locality]. */ @Column ( name = \"author_name_locality\" , nullable = false ) val authorNameLocality : String , /** * Enables query criteria for [NewsPaperContractState.author.name.state]. */ @Column ( name = \"author_name_state\" ) val authorNameState : String? = null , /** * Enables query criteria for [NewsPaperContractState.author.name.country]. */ @Column ( name = \"author_name_country\" , nullable = false ) val authorNameCountry : String , /** * Enables query criteria for [NewsPaperContractState.price]. */ @Column ( name = \"price\" , nullable = false ) val price : BigDecimal , /** * Enables query criteria for [NewsPaperContractState.editions]. */ @Column ( name = \"editions\" , nullable = false ) val editions : Int , /** * Enables query criteria for [NewsPaperContractState.title]. */ @Column ( name = \"title\" , nullable = false ) val title : String , /** * Enables query criteria for [NewsPaperContractState.published]. */ @Column ( name = \"published\" , nullable = false ) val published : Date , /** * Enables query criteria for [NewsPaperContractState.alternativeTitle]. */ @Column ( name = \"description\" , length = 500 ) val alternativeTitle : String? = null ) : PersistentState ()","title":"Generated PersistentState"},{"location":"installation/","text":"Installation \u00b6 Step 1: Add Lean State to your Contract Cordapp\u2019s Gradle build-time dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.corda.leanstate:leanstate-contracts:$leanstate_version\" // Annotation processing kapt \"com.github.manosbatsis.corda.leanstate:leanstate-processor:$leanstate_version\" // Corda dependencies etc. // ... } You don\u2019t need any Lean State dependencies at runtime . Again, no reason whatsoever to use compile , add dependencies to deployNodes or copy Lean State JARs in your Node\u2019s cordapps folder. Step 2: You may also want to add the generated sources to your cordapp\u2019s Gradle sourceSets e.g.: // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } }","title":"Installation"},{"location":"installation/#installation","text":"Step 1: Add Lean State to your Contract Cordapp\u2019s Gradle build-time dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.corda.leanstate:leanstate-contracts:$leanstate_version\" // Annotation processing kapt \"com.github.manosbatsis.corda.leanstate:leanstate-processor:$leanstate_version\" // Corda dependencies etc. // ... } You don\u2019t need any Lean State dependencies at runtime . Again, no reason whatsoever to use compile , add dependencies to deployNodes or copy Lean State JARs in your Node\u2019s cordapps folder. Step 2: You may also want to add the generated sources to your cordapp\u2019s Gradle sourceSets e.g.: // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } }","title":"Installation"},{"location":"state-model/","text":"State Model \u00b6 Sample State \u00b6 Let\u2019s start with a simple state model: /** Our contract class */ class NewsPaperContract : Contract { /** State definition */ @LeanStateModel interface NewsPaper { val publisher : Party? val author : Party //... } } Targeting a Contract \u00b6 In the above example the NewsPaper type is contained in a Corda Contract so there is no need to specify the contract type target for the generated ContractState . If NewsPaper was in a standalone file, we would specify the contract using LeanStateModel.contractClass : /** Standalone state definition */ @LeanStateModel ( contractClass = NewsPaperContract :: class ) interface NewsPaper { val publisher : Party? val author : Party //... } or using a classname string with LeanStateModel.contractClassName : /** Standalone state definition */ @LeanStateModel ( contractClassName = \"my.package.NewsPaperContract\" ) interface NewsPaper { val publisher : Party? val author : Party //... } Property Initializers \u00b6 To add default value initializers to your contract state, use @LeanStateProperty.initializer like shown bellow: @LeanStateModel interface NewsPaper { //... @get : LeanStateProperty ( initializer = \"NewsPaperStatus.FOOBAR\" ) val status : NewsPaperStatus } Default Participants \u00b6 The default strategy used by the annotation processor scans your interface and uses members of the following types to create the default participants implementation: net.corda.core.identity.Party net.corda.core.identity.AbstractParty net.corda.core.identity.AnonymousParty java.security.PublicKey Types with a proper party member, e.g. com.github.manosbatsis.vaultaire.dto.AccountParty Any collection parameterised with one of the above Overriding LinearState \u00b6 If besides all other options available you still want to directly customise the overrides for LinearState you can so it in your interface. The annotation processor will honor them by not generating its own. /** State definition */ @LeanStateModel interface NewsPaper : LinearState { val publisher : Party? val author : Party //... // Optional, no need to add or override explicitly override val linearId : UniqueIdentifier // Optionally override LinearState.participants // if you don't want the implementation generated by default override val participants get () = listOfNotNull ( publisher ?. party , author . party ) } Custom Table Name \u00b6 To customise the generated @Table annotation use @LeanStateModel.tableName like shown bellow: @LeanStateModel ( tableName = \"custom_table_name\" ) interface NewsPaper { //... } Custom Migration Resource \u00b6 To customise the generated MappedSchema implementation for using a custom Liquibase migrationResource , use @LeanStateModel.migrationResource like shown bellow: @LeanStateModel ( migrationResource = \"custom-newspaper-schema-v1.changelog-master.xml\" ) interface NewsPaper { //... } this will generate Overriding QueryableState \u00b6 If besides all other options available you still want to directly customise overrides for QueryableState you can do so in your interface. The annotation processor will honor them by not generating its own. @LeanStateModel interface NewsPaper : QueryableState { val publisher : Party? val author : Party //... // Optional, only override to use a custom implementation // VS the default strategy. override fun generateMappedObject ( schema : MappedSchema ) = NewsPaperPersistentState ( // ... ) // Only extend QueryableState and override if you don't want the implementation generated by default override fun supportedSchemas () = listOf ( SchemaV1 ) // Only add if you explicitly implement supportedSchemas() object Schema object NSchemaV1 : MappedSchema ( NewsPaperSchema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) } Property Mapping Modes \u00b6 [LeanStateModel] and [LeanStateProperty] annotations allow configuration of Contract to Persistent State property mappings using one or more of the following: NATIVE : Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY : Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED : Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members. // Tweak mapping modes at type level, // default is [PropertyMappingMode.EXPANDED], @LeanStateModel ( mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? // Tweak modes at property level @LeanStateProperty ( mappingModes = [ PropertyMappingMode . STRINGIFY ] ) val author : Party //... } JPA Overrides \u00b6 JPA @Column annotations found in your model interface will be copied as-is, overriding the annotation processor defaults. @LeanStateModel interface NewsPaper { // Override JPA Column generation @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? //... }","title":"State Model"},{"location":"state-model/#state-model","text":"","title":"State Model"},{"location":"state-model/#sample-state","text":"Let\u2019s start with a simple state model: /** Our contract class */ class NewsPaperContract : Contract { /** State definition */ @LeanStateModel interface NewsPaper { val publisher : Party? val author : Party //... } }","title":"Sample State"},{"location":"state-model/#targeting-a-contract","text":"In the above example the NewsPaper type is contained in a Corda Contract so there is no need to specify the contract type target for the generated ContractState . If NewsPaper was in a standalone file, we would specify the contract using LeanStateModel.contractClass : /** Standalone state definition */ @LeanStateModel ( contractClass = NewsPaperContract :: class ) interface NewsPaper { val publisher : Party? val author : Party //... } or using a classname string with LeanStateModel.contractClassName : /** Standalone state definition */ @LeanStateModel ( contractClassName = \"my.package.NewsPaperContract\" ) interface NewsPaper { val publisher : Party? val author : Party //... }","title":"Targeting a Contract"},{"location":"state-model/#property-initializers","text":"To add default value initializers to your contract state, use @LeanStateProperty.initializer like shown bellow: @LeanStateModel interface NewsPaper { //... @get : LeanStateProperty ( initializer = \"NewsPaperStatus.FOOBAR\" ) val status : NewsPaperStatus }","title":"Property Initializers"},{"location":"state-model/#default-participants","text":"The default strategy used by the annotation processor scans your interface and uses members of the following types to create the default participants implementation: net.corda.core.identity.Party net.corda.core.identity.AbstractParty net.corda.core.identity.AnonymousParty java.security.PublicKey Types with a proper party member, e.g. com.github.manosbatsis.vaultaire.dto.AccountParty Any collection parameterised with one of the above","title":"Default Participants"},{"location":"state-model/#overriding-linearstate","text":"If besides all other options available you still want to directly customise the overrides for LinearState you can so it in your interface. The annotation processor will honor them by not generating its own. /** State definition */ @LeanStateModel interface NewsPaper : LinearState { val publisher : Party? val author : Party //... // Optional, no need to add or override explicitly override val linearId : UniqueIdentifier // Optionally override LinearState.participants // if you don't want the implementation generated by default override val participants get () = listOfNotNull ( publisher ?. party , author . party ) }","title":"Overriding LinearState"},{"location":"state-model/#custom-table-name","text":"To customise the generated @Table annotation use @LeanStateModel.tableName like shown bellow: @LeanStateModel ( tableName = \"custom_table_name\" ) interface NewsPaper { //... }","title":"Custom Table Name"},{"location":"state-model/#custom-migration-resource","text":"To customise the generated MappedSchema implementation for using a custom Liquibase migrationResource , use @LeanStateModel.migrationResource like shown bellow: @LeanStateModel ( migrationResource = \"custom-newspaper-schema-v1.changelog-master.xml\" ) interface NewsPaper { //... } this will generate","title":"Custom Migration Resource"},{"location":"state-model/#overriding-queryablestate","text":"If besides all other options available you still want to directly customise overrides for QueryableState you can do so in your interface. The annotation processor will honor them by not generating its own. @LeanStateModel interface NewsPaper : QueryableState { val publisher : Party? val author : Party //... // Optional, only override to use a custom implementation // VS the default strategy. override fun generateMappedObject ( schema : MappedSchema ) = NewsPaperPersistentState ( // ... ) // Only extend QueryableState and override if you don't want the implementation generated by default override fun supportedSchemas () = listOf ( SchemaV1 ) // Only add if you explicitly implement supportedSchemas() object Schema object NSchemaV1 : MappedSchema ( NewsPaperSchema :: class . java , 1 , listOf ( NewsPaperPersistentState :: class . java )) }","title":"Overriding QueryableState"},{"location":"state-model/#property-mapping-modes","text":"[LeanStateModel] and [LeanStateProperty] annotations allow configuration of Contract to Persistent State property mappings using one or more of the following: NATIVE : Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY : Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED : Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members. // Tweak mapping modes at type level, // default is [PropertyMappingMode.EXPANDED], @LeanStateModel ( mappingModes = [ PropertyMappingMode . NATIVE , PropertyMappingMode . STRINGIFY , PropertyMappingMode . EXPANDED ] ) interface NewsPaper { val publisher : Party? // Tweak modes at property level @LeanStateProperty ( mappingModes = [ PropertyMappingMode . STRINGIFY ] ) val author : Party //... }","title":"Property Mapping Modes"},{"location":"state-model/#jpa-overrides","text":"JPA @Column annotations found in your model interface will be copied as-is, overriding the annotation processor defaults. @LeanStateModel interface NewsPaper { // Override JPA Column generation @get : Column ( name = \"alt_title\" , length = 500 ) val alternativeTitle : String? //... }","title":"JPA Overrides"},{"location":"0.x/","text":"Packages \u00b6 Name Summary com.github.manosbatsis.corda.leanstate com.github.manosbatsis.corda.leanstate.annotation Index \u00b6 All Types","title":"Index"},{"location":"0.x/#packages","text":"Name Summary com.github.manosbatsis.corda.leanstate com.github.manosbatsis.corda.leanstate.annotation","title":"Packages"},{"location":"0.x/#index","text":"All Types","title":"Index"},{"location":"0.x/alltypes/","text":"All Types \u00b6 Name Summary com.github.manosbatsis.corda.leanstate.LeanStateCordapp com.github.manosbatsis.corda.leanstate.annotation.LeanStateModel Generate ContractState , PersistentState types based on the annotated interface. com.github.manosbatsis.corda.leanstate.annotation.LeanStateProperty Property-level equivalent of LeanStateModel com.github.manosbatsis.corda.leanstate.annotation.NONE com.github.manosbatsis.corda.leanstate.annotation.ParticipantsState Helpers for (generated) implementations of ContractState.participants . com.github.manosbatsis.corda.leanstate.annotation.PropertyMappingMode Used by LeanStateModel and LeanStateProperty to apply one or more mapping modes in generated contract > persistent states. net.corda.core.transactions.TransactionBuilder (extensions in package com.github.manosbatsis.corda.leanstate)","title":"Index"},{"location":"0.x/alltypes/#all-types","text":"Name Summary com.github.manosbatsis.corda.leanstate.LeanStateCordapp com.github.manosbatsis.corda.leanstate.annotation.LeanStateModel Generate ContractState , PersistentState types based on the annotated interface. com.github.manosbatsis.corda.leanstate.annotation.LeanStateProperty Property-level equivalent of LeanStateModel com.github.manosbatsis.corda.leanstate.annotation.NONE com.github.manosbatsis.corda.leanstate.annotation.ParticipantsState Helpers for (generated) implementations of ContractState.participants . com.github.manosbatsis.corda.leanstate.annotation.PropertyMappingMode Used by LeanStateModel and LeanStateProperty to apply one or more mapping modes in generated contract > persistent states. net.corda.core.transactions.TransactionBuilder (extensions in package com.github.manosbatsis.corda.leanstate)","title":"All Types"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/","text":"com.github.manosbatsis.corda.leanstate Package com.github.manosbatsis.corda.leanstate \u00b6 Types \u00b6 Name Summary LeanStateCordapp class LeanStateCordapp Extensions for External Classes \u00b6 Name Summary net.corda.core.transactions.TransactionBuilder","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/#package-comgithubmanosbatsiscordaleanstate","text":"","title":"Package com.github.manosbatsis.corda.leanstate"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/#types","text":"Name Summary LeanStateCordapp class LeanStateCordapp","title":"Types"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/#extensions-for-external-classes","text":"Name Summary net.corda.core.transactions.TransactionBuilder","title":"Extensions for External Classes"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/-lean-state-cordapp/","text":"com.github.manosbatsis.corda.leanstate / LeanStateCordapp LeanStateCordapp \u00b6 class LeanStateCordapp Constructors \u00b6 Name Summary <init> LeanStateCordapp()","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/-lean-state-cordapp/#leanstatecordapp","text":"class LeanStateCordapp","title":"LeanStateCordapp"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/-lean-state-cordapp/#constructors","text":"Name Summary <init> LeanStateCordapp()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/-lean-state-cordapp/-init-/","text":"com.github.manosbatsis.corda.leanstate / LeanStateCordapp / <init> <init> \u00b6 LeanStateCordapp()","title":" init "},{"location":"0.x/com.github.manosbatsis.corda.leanstate/-lean-state-cordapp/-init-/#init","text":"LeanStateCordapp()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/net.corda.core.transactions.-transaction-builder/","text":"com.github.manosbatsis.corda.leanstate / net.corda.core.transactions.TransactionBuilder Extensions for net.corda.core.transactions.TransactionBuilder \u00b6 Name Summary attachLeanStateJar fun TransactionBuilder.attachLeanStateJar(serviceHub: ServiceHub): Unit","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/net.corda.core.transactions.-transaction-builder/#extensions-for-netcordacoretransactionstransactionbuilder","text":"Name Summary attachLeanStateJar fun TransactionBuilder.attachLeanStateJar(serviceHub: ServiceHub): Unit","title":"Extensions for net.corda.core.transactions.TransactionBuilder"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/net.corda.core.transactions.-transaction-builder/attach-lean-state-jar/","text":"com.github.manosbatsis.corda.leanstate / net.corda.core.transactions.TransactionBuilder / attachLeanStateJar attachLeanStateJar \u00b6 fun TransactionBuilder.attachLeanStateJar(serviceHub: ServiceHub): Unit","title":"Attach lean state jar"},{"location":"0.x/com.github.manosbatsis.corda.leanstate/net.corda.core.transactions.-transaction-builder/attach-lean-state-jar/#attachleanstatejar","text":"fun TransactionBuilder.attachLeanStateJar(serviceHub: ServiceHub): Unit","title":"attachLeanStateJar"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/","text":"com.github.manosbatsis.corda.leanstate.annotation Package com.github.manosbatsis.corda.leanstate.annotation \u00b6 Types \u00b6 Name Summary NONE class NONE ParticipantsState interface ParticipantsState Helpers for (generated) implementations of ContractState.participants . PropertyMappingMode enum class PropertyMappingMode Used by LeanStateModel and LeanStateProperty to apply one or more mapping modes in generated contract > persistent states. Annotations \u00b6 Name Summary LeanStateModel annotation class LeanStateModel Generate ContractState , PersistentState types based on the annotated interface. LeanStateProperty annotation class LeanStateProperty Property-level equivalent of LeanStateModel","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/#package-comgithubmanosbatsiscordaleanstateannotation","text":"","title":"Package com.github.manosbatsis.corda.leanstate.annotation"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/#types","text":"Name Summary NONE class NONE ParticipantsState interface ParticipantsState Helpers for (generated) implementations of ContractState.participants . PropertyMappingMode enum class PropertyMappingMode Used by LeanStateModel and LeanStateProperty to apply one or more mapping modes in generated contract > persistent states.","title":"Types"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/#annotations","text":"Name Summary LeanStateModel annotation class LeanStateModel Generate ContractState , PersistentState types based on the annotated interface. LeanStateProperty annotation class LeanStateProperty Property-level equivalent of LeanStateModel","title":"Annotations"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel LeanStateModel \u00b6 @Target([AnnotationTarget.CLASS]) annotation class LeanStateModel Generate ContractState , PersistentState types based on the annotated interface. Constructors \u00b6 Name Summary <init> LeanStateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\", tableName: String = \"\", migrationResource: String = \"\") Generate ContractState , PersistentState types based on the annotated interface. Properties \u00b6 Name Summary contractClass val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type. contractClassName val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time. contractStateInterface val contractStateInterface: KClass<out ContractState> contractStateName val contractStateName: String copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via LeanStateProperty annotations. migrationResource val migrationResource: String persistentStateName val persistentStateName: String tableName val tableName: String","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/#leanstatemodel","text":"@Target([AnnotationTarget.CLASS]) annotation class LeanStateModel Generate ContractState , PersistentState types based on the annotated interface.","title":"LeanStateModel"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/#constructors","text":"Name Summary <init> LeanStateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\", tableName: String = \"\", migrationResource: String = \"\") Generate ContractState , PersistentState types based on the annotated interface.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/#properties","text":"Name Summary contractClass val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type. contractClassName val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time. contractStateInterface val contractStateInterface: KClass<out ContractState> contractStateName val contractStateName: String copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via LeanStateProperty annotations. migrationResource val migrationResource: String persistentStateName val persistentStateName: String tableName val tableName: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/-init-/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / <init> <init> \u00b6 LeanStateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\", tableName: String = \"\", migrationResource: String = \"\") Generate ContractState , PersistentState types based on the annotated interface.","title":" init "},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/-init-/#init","text":"LeanStateModel(contractClass: KClass<out Contract> = Contract::class, contractClassName: String = \"\", mappingModes: Array< PropertyMappingMode > = [PropertyMappingMode.EXPANDED], ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], contractStateInterface: KClass<out ContractState> = ContractState::class, contractStateName: String = \"\", persistentStateName: String = \"\", tableName: String = \"\", migrationResource: String = \"\") Generate ContractState , PersistentState types based on the annotated interface.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-class-name/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / contractClassName contractClassName \u00b6 val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time.","title":"Contract class name"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-class-name/#contractclassname","text":"val contractClassName: String Configures the BelongsToContract annotation added to the generated ContractState .. Required unless contractClass is used instead or the annotated interface is contained in a Contract type, otherwise convenient when contractClass cannot be used at build time.","title":"contractClassName"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-class/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / contractClass contractClass \u00b6 val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type.","title":"Contract class"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-class/#contractclass","text":"val contractClass: KClass<out Contract> Configures the BelongsToContract annotation added to the generated ContractState . Takes precedence over contractClassName ,using one of the two is required, unless the annotated interface is contained in a Contract type.","title":"contractClass"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-state-interface/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / contractStateInterface contractStateInterface \u00b6 val contractStateInterface: KClass<out ContractState>","title":"Contract state interface"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-state-interface/#contractstateinterface","text":"val contractStateInterface: KClass<out ContractState>","title":"contractStateInterface"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-state-name/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / contractStateName contractStateName \u00b6 val contractStateName: String","title":"Contract state name"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/contract-state-name/#contractstatename","text":"val contractStateName: String","title":"contractStateName"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/copy-annotation-packages/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / copyAnnotationPackages copyAnnotationPackages \u00b6 val copyAnnotationPackages: Array<String>","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array<String>","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/ignore-properties/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / ignoreProperties ignoreProperties \u00b6 val ignoreProperties: Array<String>","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array<String>","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/mapping-modes/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / mappingModes mappingModes \u00b6 val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via LeanStateProperty annotations.","title":"Mapping modes"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/mapping-modes/#mappingmodes","text":"val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED . Can be overridden per property via LeanStateProperty annotations.","title":"mappingModes"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/migration-resource/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / migrationResource migrationResource \u00b6 val migrationResource: String","title":"Migration resource"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/migration-resource/#migrationresource","text":"val migrationResource: String","title":"migrationResource"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/persistent-state-name/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / persistentStateName persistentStateName \u00b6 val persistentStateName: String","title":"Persistent state name"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/persistent-state-name/#persistentstatename","text":"val persistentStateName: String","title":"persistentStateName"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/table-name/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateModel / tableName tableName \u00b6 val tableName: String","title":"Table name"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-model/table-name/#tablename","text":"val tableName: String","title":"tableName"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateProperty LeanStateProperty \u00b6 @Target([AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class LeanStateProperty Property-level equivalent of LeanStateModel Constructors \u00b6 Name Summary <init> LeanStateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of LeanStateModel Properties \u00b6 Name Summary initializer val initializer: String mapper val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property. mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/#leanstateproperty","text":"@Target([AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class LeanStateProperty Property-level equivalent of LeanStateModel","title":"LeanStateProperty"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/#constructors","text":"Name Summary <init> LeanStateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of LeanStateModel","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/#properties","text":"Name Summary initializer val initializer: String mapper val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property. mappingModes val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"Properties"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/-init-/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateProperty / <init> <init> \u00b6 LeanStateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of LeanStateModel","title":" init "},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/-init-/#init","text":"LeanStateProperty(mapper: String = \"\", mappingModes: Array< PropertyMappingMode > = [], initializer: String) Property-level equivalent of LeanStateModel","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/initializer/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateProperty / initializer initializer \u00b6 val initializer: String","title":"Initializer"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/initializer/#initializer","text":"val initializer: String","title":"initializer"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/mapper/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateProperty / mapper mapper \u00b6 val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property.","title":"Mapper"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/mapper/#mapper","text":"val mapper: String Apply a custom implementation of com.github.manosbatsis.vaultaire.processor.state.mapping.PersistentPropertyMapper to this property.","title":"mapper"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/mapping-modes/","text":"com.github.manosbatsis.corda.leanstate.annotation / LeanStateProperty / mappingModes mappingModes \u00b6 val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"Mapping modes"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-lean-state-property/mapping-modes/#mappingmodes","text":"val mappingModes: Array< PropertyMappingMode > The type-level mode(s) for mapping ContractState to PersistentState properties. The default is PropertyMappingMode.EXPANDED .","title":"mappingModes"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-n-o-n-e/","text":"com.github.manosbatsis.corda.leanstate.annotation / NONE NONE \u00b6 class NONE Constructors \u00b6 Name Summary <init> NONE()","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-n-o-n-e/#none","text":"class NONE","title":"NONE"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-n-o-n-e/#constructors","text":"Name Summary <init> NONE()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-n-o-n-e/-init-/","text":"com.github.manosbatsis.corda.leanstate.annotation / NONE / <init> <init> \u00b6 NONE()","title":" init "},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-n-o-n-e/-init-/#init","text":"NONE()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/","text":"com.github.manosbatsis.corda.leanstate.annotation / ParticipantsState ParticipantsState \u00b6 interface ParticipantsState Helpers for (generated) implementations of ContractState.participants . Functions \u00b6 Name Summary toAbstractParties open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty> toAbstractParty open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty toParticipants open fun toParticipants(vararg entry: Any?): List<AbstractParty> Companion Object Functions \u00b6 Name Summary getField fun Any.getField(fieldName: String): Any? isKotlinClass fun Class<*>.isKotlinClass(): Boolean isKotlinType fun Any.isKotlinType(): Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/#participantsstate","text":"interface ParticipantsState Helpers for (generated) implementations of ContractState.participants .","title":"ParticipantsState"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/#functions","text":"Name Summary toAbstractParties open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty> toAbstractParty open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty toParticipants open fun toParticipants(vararg entry: Any?): List<AbstractParty>","title":"Functions"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/#companion-object-functions","text":"Name Summary getField fun Any.getField(fieldName: String): Any? isKotlinClass fun Class<*>.isKotlinClass(): Boolean isKotlinType fun Any.isKotlinType(): Boolean","title":"Companion Object Functions"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/get-field/","text":"com.github.manosbatsis.corda.leanstate.annotation / ParticipantsState / getField getField \u00b6 fun Any.getField(fieldName: String): Any?","title":"Get field"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/get-field/#getfield","text":"fun Any.getField(fieldName: String): Any?","title":"getField"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/is-kotlin-class/","text":"com.github.manosbatsis.corda.leanstate.annotation / ParticipantsState / isKotlinClass isKotlinClass \u00b6 fun Class<*>.isKotlinClass(): Boolean","title":"Is kotlin class"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/is-kotlin-class/#iskotlinclass","text":"fun Class<*>.isKotlinClass(): Boolean","title":"isKotlinClass"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/is-kotlin-type/","text":"com.github.manosbatsis.corda.leanstate.annotation / ParticipantsState / isKotlinType isKotlinType \u00b6 fun Any.isKotlinType(): Boolean","title":"Is kotlin type"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/is-kotlin-type/#iskotlintype","text":"fun Any.isKotlinType(): Boolean","title":"isKotlinType"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/to-abstract-parties/","text":"com.github.manosbatsis.corda.leanstate.annotation / ParticipantsState / toAbstractParties toAbstractParties \u00b6 open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty>","title":"To abstract parties"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/to-abstract-parties/#toabstractparties","text":"open fun toAbstractParties(entries: Collection<*>?): List<AbstractParty>","title":"toAbstractParties"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/to-abstract-party/","text":"com.github.manosbatsis.corda.leanstate.annotation / ParticipantsState / toAbstractParty toAbstractParty \u00b6 open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty","title":"To abstract party"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/to-abstract-party/#toabstractparty","text":"open fun toAbstractParty(entry: Any?): AbstractParty? open fun toAbstractParty(publicKey: PublicKey): AnonymousParty","title":"toAbstractParty"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/to-participants/","text":"com.github.manosbatsis.corda.leanstate.annotation / ParticipantsState / toParticipants toParticipants \u00b6 open fun toParticipants(vararg entry: Any?): List<AbstractParty>","title":"To participants"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-participants-state/to-participants/#toparticipants","text":"open fun toParticipants(vararg entry: Any?): List<AbstractParty>","title":"toParticipants"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/","text":"com.github.manosbatsis.corda.leanstate.annotation / PropertyMappingMode PropertyMappingMode \u00b6 enum class PropertyMappingMode Used by LeanStateModel and LeanStateProperty to apply one or more mapping modes in generated contract > persistent states. Enum Values \u00b6 Name Summary NATIVE Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":"Index"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/#propertymappingmode","text":"enum class PropertyMappingMode Used by LeanStateModel and LeanStateProperty to apply one or more mapping modes in generated contract > persistent states.","title":"PropertyMappingMode"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/#enum-values","text":"Name Summary NATIVE Will generate PersistentState fields using the original ContractState field if possible. STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d. EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":"Enum Values"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/-e-x-p-a-n-d-e-d/","text":"com.github.manosbatsis.corda.leanstate.annotation / PropertyMappingMode / EXPANDED EXPANDED \u00b6 EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":" e x p a n d e d"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/-e-x-p-a-n-d-e-d/#expanded","text":"EXPANDED Will generate PersistentState fields by expanding applicable types to properties corresponding to their individual members.","title":"EXPANDED"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/-n-a-t-i-v-e/","text":"com.github.manosbatsis.corda.leanstate.annotation / PropertyMappingMode / NATIVE NATIVE \u00b6 NATIVE Will generate PersistentState fields using the original ContractState field if possible.","title":" n a t i v e"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/-n-a-t-i-v-e/#native","text":"NATIVE Will generate PersistentState fields using the original ContractState field if possible.","title":"NATIVE"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/-s-t-r-i-n-g-i-f-y/","text":"com.github.manosbatsis.corda.leanstate.annotation / PropertyMappingMode / STRINGIFY STRINGIFY \u00b6 STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d.","title":" s t r i n g i f y"},{"location":"0.x/com.github.manosbatsis.corda.leanstate.annotation/-property-mapping-mode/-s-t-r-i-n-g-i-f-y/#stringify","text":"STRINGIFY Will generate string-based PersistentState field variants where applicable, suffixing their names with \u201cString\u201d.","title":"STRINGIFY"}]}